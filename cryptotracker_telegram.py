# -*- coding: utf-8 -*-
"""CryptoTracker_Telegram

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DC9sFQ02kE7Uc_N9Xx3mXQbPIwPUH-lP
"""

!pip install selenium pandas openpyxl undetected-chromedriver python-dotenv schedule

import os
import time
import pandas as pd
import requests
import schedule
import sqlite3
import matplotlib.pyplot as plt
import undetected_chromedriver as uc
from dotenv import load_dotenv
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

load_dotenv()
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    raise ValueError("‚ùå ERRO: Token ou Chat ID do Telegram n√£o foram carregados corretamente!")

print("‚úÖ Credenciais do Telegram carregadas com sucesso!")

options = uc.ChromeOptions()
options.add_argument("--headless")
options.add_argument("--no-sandbox")
options.add_argument("--disable-dev-shm-usage")

driver = uc.Chrome(options=options)

conn = sqlite3.connect("crypto_data.db")
cursor = conn.cursor()
cursor.execute("""
    CREATE TABLE IF NOT EXISTS cryptos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT,
        name TEXT,
        market_cap TEXT
    )
""")
conn.commit()

def coletar_dados():
    print("üîÑ Buscando dados...")
    url = "https://www.coingecko.com/pt"
    driver.get(url)
    time.sleep(5)

    moedas = driver.find_elements(By.XPATH, "//tbody/tr")[:10]

    dados = []
    mensagem = "üìä **Atualiza√ß√£o das Criptomoedas:**\n"

    for i, moeda in enumerate(moedas, start=1):
        try:
            nome = moeda.find_element(By.XPATH, ".//td[3]//a").text
            market_cap = moeda.find_element(By.XPATH, ".//td[10]").text
            dados.append((nome, market_cap))
            mensagem += f"\nüîπ {nome} - Market Cap: {market_cap}"

            cursor.execute("INSERT INTO cryptos (timestamp, name, market_cap) VALUES (datetime('now'), ?, ?)", (nome, market_cap))
            conn.commit()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao coletar dados da moeda {i}: {e}")

    print("‚úÖ Dados coletados com sucesso!")
    enviar_telegram(mensagem)

    return dados

def enviar_telegram(mensagem):
    url_mensagem = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {"chat_id": TELEGRAM_CHAT_ID, "text": mensagem}
    requests.post(url_mensagem, data=payload)

def gerar_grafico():
    df = pd.read_sql_query("SELECT name, market_cap, timestamp FROM cryptos", conn)

    if df.empty:
        print("‚ö†Ô∏è Sem dados suficientes para gerar gr√°ficos.")
        return

    df["market_cap"] = df["market_cap"].str.replace("US$", "").str.replace(",", "").astype(float)

    plt.figure(figsize=(12, 6))
    for nome in df["name"].unique():
        dados = df[df["name"] == nome]
        plt.plot(dados["timestamp"], dados["market_cap"], marker="o", label=nome)

    plt.title("Hist√≥rico de Market Cap das Criptomoedas")
    plt.xlabel("Data")
    plt.ylabel("Market Cap (USD)")
    plt.legend()
    plt.xticks(rotation=45)
    plt.grid()
    plt.savefig("market_cap_history.png")
    plt.show()

    enviar_telegram("üìä Hist√≥rico de Market Cap", "market_cap_history.png")

def verificar_alertas():
    df = pd.read_sql_query("SELECT name, market_cap FROM cryptos ORDER BY timestamp DESC LIMIT 20", conn)

    if df.empty:
        return

    df["market_cap"] = df["market_cap"].str.replace("US$", "").str.replace(",", "").astype(float)
    alertas = []

    for _, row in df.iterrows():
        nome = row["name"]
        market_cap_atual = row["market_cap"]

        cursor.execute("SELECT market_cap FROM cryptos WHERE name = ? ORDER BY timestamp DESC LIMIT 2", (nome,))
        historico = cursor.fetchall()

        if len(historico) < 2:
            continue

        market_cap_anterior = float(historico[1][0].replace("US$", "").replace(",", ""))

        variacao = ((market_cap_atual - market_cap_anterior) / market_cap_anterior) * 100

        if abs(variacao) > 5:
            alertas.append(f"‚ö†Ô∏è {nome} teve uma varia√ß√£o de {variacao:.2f}%!")

    if alertas:
        enviar_telegram("\n".join(alertas))

schedule.every(2).hours.do(coletar_dados)
schedule.every(6).hours.do(gerar_grafico)
schedule.every(1).hour.do(verificar_alertas)

print("üîÑ Iniciando o monitor de criptomoedas...")
while True:
    schedule.run_pending()
    time.sleep(60)